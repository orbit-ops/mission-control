// Code generated by ent, DO NOT EDIT.

package ogent

import (
	"context"
	"net/http"

	"github.com/go-faster/jx"
	"github.com/orbit-ops/launchpad-core/ent"
	"github.com/orbit-ops/launchpad-core/ent/access"
	"github.com/orbit-ops/launchpad-core/ent/apikey"
	"github.com/orbit-ops/launchpad-core/ent/approval"
	"github.com/orbit-ops/launchpad-core/ent/audit"
	"github.com/orbit-ops/launchpad-core/ent/mission"
	"github.com/orbit-ops/launchpad-core/ent/request"
	"github.com/orbit-ops/launchpad-core/ent/rocket"
)

// OgentHandler implements the ogen generated Handler interface and uses Ent as data layer.
type OgentHandler struct {
	client *ent.Client
}

// NewOgentHandler returns a new OgentHandler.
func NewOgentHandler(c *ent.Client) *OgentHandler { return &OgentHandler{c} }

// rawError renders err as json string.
func rawError(err error) jx.Raw {
	var e jx.Encoder
	e.Str(err.Error())
	return e.Bytes()
}

// ListAccessAccessTokens handles GET /accesses/{id}/access-tokens requests.
func (h *OgentHandler) ListAccessAccessTokens(ctx context.Context, params ListAccessAccessTokensParams) (ListAccessAccessTokensRes, error) {
	q := h.client.Access.Query().Where(access.IDEQ(params.ID)).QueryAccessTokens()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewAccessAccessTokensLists(es)
	return (*ListAccessAccessTokensOKApplicationJSON)(&r), nil
}

// CreateApiKey handles POST /api-keys requests.
func (h *OgentHandler) CreateApiKey(ctx context.Context, req *CreateApiKeyReq) (CreateApiKeyRes, error) {
	b := h.client.ApiKey.Create()
	// Add all fields.
	b.SetName(req.Name)
	b.SetKey(req.Key)
	// Add all edges.
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.ApiKey.Query().Where(apikey.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewApiKeyCreate(e), nil
}

// DeleteApiKey handles DELETE /api-keys/{id} requests.
func (h *OgentHandler) DeleteApiKey(ctx context.Context, params DeleteApiKeyParams) (DeleteApiKeyRes, error) {
	err := h.client.ApiKey.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteApiKeyNoContent), nil

}

// ListApiKey handles GET /api-keys requests.
func (h *OgentHandler) ListApiKey(ctx context.Context, params ListApiKeyParams) (ListApiKeyRes, error) {
	q := h.client.ApiKey.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewApiKeyLists(es)
	return (*ListApiKeyOKApplicationJSON)(&r), nil
}

// ReadApiKey handles GET /api-keys/{id} requests.
func (h *OgentHandler) ReadApiKey(ctx context.Context, params ReadApiKeyParams) (ReadApiKeyRes, error) {
	q := h.client.ApiKey.Query().Where(apikey.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewApiKeyRead(e), nil
}

// CreateApproval handles POST /approvals requests.
func (h *OgentHandler) CreateApproval(ctx context.Context, req *CreateApprovalReq) (CreateApprovalRes, error) {
	b := h.client.Approval.Create()
	// Add all fields.
	b.SetPerson(req.Person)
	b.SetApprovedTime(req.ApprovedTime)
	b.SetApproved(req.Approved)
	b.SetRevoked(req.Revoked)
	if v, ok := req.RevokedTime.Get(); ok {
		b.SetRevokedTime(v)
	}
	b.SetRequestID(req.RequestID)
	// Add all edges.
	b.SetRequestsID(req.Requests)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Approval.Query().Where(approval.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewApprovalCreate(e), nil
}

// ReadApproval handles GET /approvals/{id} requests.
func (h *OgentHandler) ReadApproval(ctx context.Context, params ReadApprovalParams) (ReadApprovalRes, error) {
	q := h.client.Approval.Query().Where(approval.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewApprovalRead(e), nil
}

// UpdateApproval handles PATCH /approvals/{id} requests.
func (h *OgentHandler) UpdateApproval(ctx context.Context, req *UpdateApprovalReq, params UpdateApprovalParams) (UpdateApprovalRes, error) {
	b := h.client.Approval.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.Revoked.Get(); ok {
		b.SetRevoked(v)
	}
	if v, ok := req.RevokedTime.Get(); ok {
		b.SetRevokedTime(v)
	}
	if v, ok := req.RequestID.Get(); ok {
		b.SetRequestID(v)
	}
	// Add all edges.
	if v, ok := req.Requests.Get(); ok {
		b.SetRequestsID(v)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Approval.Query().Where(approval.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewApprovalUpdate(e), nil
}

// DeleteApproval handles DELETE /approvals/{id} requests.
func (h *OgentHandler) DeleteApproval(ctx context.Context, params DeleteApprovalParams) (DeleteApprovalRes, error) {
	err := h.client.Approval.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteApprovalNoContent), nil

}

// ListApproval handles GET /approvals requests.
func (h *OgentHandler) ListApproval(ctx context.Context, params ListApprovalParams) (ListApprovalRes, error) {
	q := h.client.Approval.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewApprovalLists(es)
	return (*ListApprovalOKApplicationJSON)(&r), nil
}

// ListAudit handles GET /audits requests.
func (h *OgentHandler) ListAudit(ctx context.Context, params ListAuditParams) (ListAuditRes, error) {
	q := h.client.Audit.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewAuditLists(es)
	return (*ListAuditOKApplicationJSON)(&r), nil
}

// ReadAudit handles GET /audits/{id} requests.
func (h *OgentHandler) ReadAudit(ctx context.Context, params ReadAuditParams) (ReadAuditRes, error) {
	q := h.client.Audit.Query().Where(audit.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewAuditRead(e), nil
}

// CreateMission handles POST /missions requests.
func (h *OgentHandler) CreateMission(ctx context.Context, req *CreateMissionReq) (CreateMissionRes, error) {
	b := h.client.Mission.Create()
	// Add all fields.
	if v, ok := req.Description.Get(); ok {
		b.SetDescription(v)
	}
	b.SetMinApprovers(req.MinApprovers)
	b.SetPossibleApprovers(req.PossibleApprovers)
	// Add all edges.
	b.AddRocketIDs(req.Rockets...)
	b.AddRequestIDs(req.Requests...)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Mission.Query().Where(mission.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewMissionCreate(e), nil
}

// ReadMission handles GET /missions/{id} requests.
func (h *OgentHandler) ReadMission(ctx context.Context, params ReadMissionParams) (ReadMissionRes, error) {
	q := h.client.Mission.Query().Where(mission.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewMissionRead(e), nil
}

// UpdateMission handles PATCH /missions/{id} requests.
func (h *OgentHandler) UpdateMission(ctx context.Context, req *UpdateMissionReq, params UpdateMissionParams) (UpdateMissionRes, error) {
	b := h.client.Mission.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.Description.Get(); ok {
		b.SetDescription(v)
	}
	if v, ok := req.MinApprovers.Get(); ok {
		b.SetMinApprovers(v)
	}
	if req.PossibleApprovers != nil {
		b.SetPossibleApprovers(req.PossibleApprovers)
	}
	// Add all edges.
	if req.Requests != nil {
		b.ClearRequests().AddRequestIDs(req.Requests...)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Mission.Query().Where(mission.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewMissionUpdate(e), nil
}

// DeleteMission handles DELETE /missions/{id} requests.
func (h *OgentHandler) DeleteMission(ctx context.Context, params DeleteMissionParams) (DeleteMissionRes, error) {
	err := h.client.Mission.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteMissionNoContent), nil

}

// ListMission handles GET /missions requests.
func (h *OgentHandler) ListMission(ctx context.Context, params ListMissionParams) (ListMissionRes, error) {
	q := h.client.Mission.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewMissionLists(es)
	return (*ListMissionOKApplicationJSON)(&r), nil
}

// ListMissionRockets handles GET /missions/{id}/rockets requests.
func (h *OgentHandler) ListMissionRockets(ctx context.Context, params ListMissionRocketsParams) (ListMissionRocketsRes, error) {
	q := h.client.Mission.Query().Where(mission.IDEQ(params.ID)).QueryRockets()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewMissionRocketsLists(es)
	return (*ListMissionRocketsOKApplicationJSON)(&r), nil
}

// ListMissionRequests handles GET /missions/{id}/requests requests.
func (h *OgentHandler) ListMissionRequests(ctx context.Context, params ListMissionRequestsParams) (ListMissionRequestsRes, error) {
	q := h.client.Mission.Query().Where(mission.IDEQ(params.ID)).QueryRequests()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewMissionRequestsLists(es)
	return (*ListMissionRequestsOKApplicationJSON)(&r), nil
}

// CreateRequest handles POST /requests requests.
func (h *OgentHandler) CreateRequest(ctx context.Context, req *CreateRequestReq) (CreateRequestRes, error) {
	b := h.client.Request.Create()
	// Add all fields.
	b.SetReason(req.Reason)
	b.SetRequester(req.Requester)
	b.SetMissionID(req.MissionID)
	// Add all edges.
	b.AddApprovalIDs(req.Approvals...)
	b.SetMissionID(req.Mission)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Request.Query().Where(request.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewRequestCreate(e), nil
}

// ReadRequest handles GET /requests/{id} requests.
func (h *OgentHandler) ReadRequest(ctx context.Context, params ReadRequestParams) (ReadRequestRes, error) {
	q := h.client.Request.Query().Where(request.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewRequestRead(e), nil
}

// UpdateRequest handles PATCH /requests/{id} requests.
func (h *OgentHandler) UpdateRequest(ctx context.Context, req *UpdateRequestReq, params UpdateRequestParams) (UpdateRequestRes, error) {
	b := h.client.Request.UpdateOneID(params.ID)
	// Add all fields.
	// Add all edges.
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Request.Query().Where(request.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewRequestUpdate(e), nil
}

// DeleteRequest handles DELETE /requests/{id} requests.
func (h *OgentHandler) DeleteRequest(ctx context.Context, params DeleteRequestParams) (DeleteRequestRes, error) {
	err := h.client.Request.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteRequestNoContent), nil

}

// ListRequest handles GET /requests requests.
func (h *OgentHandler) ListRequest(ctx context.Context, params ListRequestParams) (ListRequestRes, error) {
	q := h.client.Request.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewRequestLists(es)
	return (*ListRequestOKApplicationJSON)(&r), nil
}

// ListRequestApprovals handles GET /requests/{id}/approvals requests.
func (h *OgentHandler) ListRequestApprovals(ctx context.Context, params ListRequestApprovalsParams) (ListRequestApprovalsRes, error) {
	q := h.client.Request.Query().Where(request.IDEQ(params.ID)).QueryApprovals()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewRequestApprovalsLists(es)
	return (*ListRequestApprovalsOKApplicationJSON)(&r), nil
}

// ReadRequestMission handles GET /requests/{id}/mission requests.
func (h *OgentHandler) ReadRequestMission(ctx context.Context, params ReadRequestMissionParams) (ReadRequestMissionRes, error) {
	q := h.client.Request.Query().Where(request.IDEQ(params.ID)).QueryMission()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewRequestMissionRead(e), nil
}

// CreateRocket handles POST /rockets requests.
func (h *OgentHandler) CreateRocket(ctx context.Context, req *CreateRocketReq) (CreateRocketRes, error) {
	b := h.client.Rocket.Create()
	// Add all fields.
	if v, ok := req.Description.Get(); ok {
		b.SetDescription(v)
	}
	if v, ok := req.Image.Get(); ok {
		b.SetImage(v)
	}
	if v, ok := req.Zip.Get(); ok {
		b.SetZip(v)
	}
	b.SetConfig(req.Config)
	// Add all edges.
	b.AddMissionIDs(req.Missions...)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Rocket.Query().Where(rocket.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewRocketCreate(e), nil
}

// ReadRocket handles GET /rockets/{id} requests.
func (h *OgentHandler) ReadRocket(ctx context.Context, params ReadRocketParams) (ReadRocketRes, error) {
	q := h.client.Rocket.Query().Where(rocket.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewRocketRead(e), nil
}

// UpdateRocket handles PATCH /rockets/{id} requests.
func (h *OgentHandler) UpdateRocket(ctx context.Context, req *UpdateRocketReq, params UpdateRocketParams) (UpdateRocketRes, error) {
	b := h.client.Rocket.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.Description.Get(); ok {
		b.SetDescription(v)
	}
	if v, ok := req.Image.Get(); ok {
		b.SetImage(v)
	}
	if v, ok := req.Zip.Get(); ok {
		b.SetZip(v)
	}
	if v, ok := req.Config.Get(); ok {
		b.SetConfig(v)
	}
	// Add all edges.
	if req.Missions != nil {
		b.ClearMissions().AddMissionIDs(req.Missions...)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Rocket.Query().Where(rocket.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewRocketUpdate(e), nil
}

// DeleteRocket handles DELETE /rockets/{id} requests.
func (h *OgentHandler) DeleteRocket(ctx context.Context, params DeleteRocketParams) (DeleteRocketRes, error) {
	err := h.client.Rocket.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteRocketNoContent), nil

}

// ListRocket handles GET /rockets requests.
func (h *OgentHandler) ListRocket(ctx context.Context, params ListRocketParams) (ListRocketRes, error) {
	q := h.client.Rocket.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewRocketLists(es)
	return (*ListRocketOKApplicationJSON)(&r), nil
}

// ListRocketMissions handles GET /rockets/{id}/missions requests.
func (h *OgentHandler) ListRocketMissions(ctx context.Context, params ListRocketMissionsParams) (ListRocketMissionsRes, error) {
	q := h.client.Rocket.Query().Where(rocket.IDEQ(params.ID)).QueryMissions()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewRocketMissionsLists(es)
	return (*ListRocketMissionsOKApplicationJSON)(&r), nil
}
